<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>Notes of APUE</title>
   <meta name="author" content="Elvis Kwok" />
   <link href="http://feeds.feedburner.com/" rel="alternate" title="Elvis Kwok" type="application/atom+xml" />
   <meta name="readability-verification" content="QCzSs992GxmRYRKVpPeZ6LE2tS8aYKxsSSQKV8YM"/>

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />

   <!-- Typekit -->
   <!--
   <script type="text/javascript" src="http://use.typekit.com/jpd0pfm.js"></script>
   <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
   -->
</head>
<body>

<!-- ClickTale Top part -->
<script type="text/javascript">
var WRInitTime=(new Date()).getTime();
</script>
<!-- ClickTale end of Top part -->

<div class="site">
  <div class="title">
    <a href="/">Elvis Kwok</a>
    <a class="extra" href="/">home</a>
  </div>
  
  <div id="post">
<h1>Notes of APUE</h1>

<p class="meta">22 Sep 2014 - Guangzhou</p>


<p></p>

<hr />

<p><br></p>

<p><em>ps: apue.h设置，在<a href="http://www.apuebook.com">apue官网</a>下载所有实例代码，并将<code>apue.2e/include/apue.h</code>和<code>apue/lib/error.c</code>复制到<code>/usr/lib/</code>,然后在<code>/usr/lib/apue.h</code>末尾添加<code>#include "error.c"</code></em></p>

<h1>outline</h1>

<ul>
<li>UNIX基本概念(1)，各种UNIX标准化工作(2)</li>
<li>I/O

<ul>
<li>不带缓冲的I/O(3)</li>
<li>文件和目录(4)</li>
<li>标准I/O库(5)</li>
<li>标准系统数据文件(6)</li>
</ul>
</li>
<li>进程

<ul>
<li>进程的环境(7)</li>
<li>进程控制(8)</li>
<li>进程之间的关系(9)</li>
<li>信号(10)</li>
<li>线程(11, 12)</li>
</ul>
</li>
<li>更多的I/O

<ul>
<li>终端I/O(18)</li>
<li>高级I/O(14)</li>
<li>守护进程(13)</li>
</ul>
</li>
<li>IPC

<ul>
<li>进程间通信(15)</li>
<li>网络IPC: 套接字(16)</li>
<li>高级进程间通信(17)</li>
</ul>
</li>
<li>实例

<ul>
<li>数据库的函数库(20)</li>
<li>打印机通信(21)</li>
<li>伪终端(19)<br/>
<br></li>
</ul>
</li>
</ul>


<h1>chapter 1: UNIX基础知识</h1>

<ol>
<li>引言</li>
<li>UNIX体系结构<br/>
 <img src="/images/apue/1.2.png" title="unix architecture" alt="img" /></li>
<li>登录

<ol>
<li>登录名</li>
<li>shell；<strong>命令解释器</strong>，读取用户输入（终端交互、shell脚本），然后执行命令</li>
</ol>
</li>
<li>文件和目录

<ol>
<li>文件系统：<strong>“目录+文件”</strong>组成的层次结构；目录是一个包含n个<strong>“目录项”</strong>，目录项包含文件名+文件属性信息（这是逻辑视图上，实际存储不是这样）；<code>stat</code>和<code>fstat</code>函数返回包含文件属性的一个信息结构</li>
<li>文件名</li>
<li><p>路径名；<br/>
ls命令的简单实现</p>

<pre><code>struct dirent *dirp = opendir(argv[1]);
while((dirp = readdir(dp) != NULL)
     printf("%s\n", dirp-&gt;d_name);
</code></pre></li>
<li>工作目录（current）</li>
<li>起始目录（登陆时的工作目录）</li>
</ol>
</li>
<li>输入和输出

<ol>
<li>文件描述符（file descriptor）;非负整数，内核用它标识一个特定进程正在访问的文件</li>
<li>标准输入、输出、出错（这是运行任何程序时shell打开的三个<strong>文件描述符</strong>）</li>
<li>不同缓冲的I/O；函数<code>open</code>,<code>read</code>,<code>write</code>,<code>lseek</code>,<code>close</code>；自定义BUFFSIZE，缓存由内核负责（并非没有缓存）</li>
<li>标准I/O；带缓冲的接口，无需担心最佳缓冲区大小，使用缓冲区进行输入输出；如<code>&lt;stdio.h&gt;</code>的<code>printf</code>；用标准I/O将<code>stdin</code>复制到<code>stdout</code>，从而实现文件复制，<code>c = getc(stdin); putc(c, stdout);</code></li>
</ol>
</li>
<li>程序与进程

<ol>
<li>程序：存放在磁盘的可执行文件，由内核将程序读入存储器（使用<code>exec</code>函数）</li>
<li>进程（程序的执行实例），进程ID（唯一的数字标识符，非负整数，<code>getpid()</code>）</li>
<li>进程控制（3个函数）：<code>fork</code>(创建新进程，向父进程返回新子进程的进程ID，向子进程返回0)、<code>exec（执行命令）</code>、<code>waitpid（可以用来实现父进程等待子进程的种植）</code>; shell程序的简单实现（从标准输入读命令并执行）；<code>if(buf[strlen(buf) -1] == '\n')</code>,<code>pid_t pid = fork();</code>,<code>execlp(buf, buf, (char *)0);</code></li>
<li>线程和线程ID；<strong>一个进程内</strong>的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性，能访问同意存储区，访问共享数据时需要采取同步措施</li>
</ol>
</li>
<li><p>出错处理；errno整型变量；出错恢复（致命性：无法恢复，最多print出错信息；非致命性：例如资源紧缺，可延迟再试）
 打印出错信息的两个函数</p>

<pre><code class="`"> #include &lt;string.h&gt;
 char *strerro(int errnum);  /* 返回值：指向消息字符串的指针 */
</code></pre>

<pre><code class="`"> #include &lt;stdio.h&gt;
 void perro(const char *msg);    /* 输出msg字符串： errno值对应的出错信息 */
</code></pre></li>
<li>用户标识

<ol>
<li>用户ID；<code>getuid()</code></li>
<li>组ID；<code>getgid()</code></li>
<li>附加组ID</li>
</ol>
</li>
<li>信号；通知进程已经发生某种情况的一种技术；编写sign_int函数</li>
<li>时间值； <br/>
日历时间（国际标准时间UTC）
进程时间（CPU时间）：时钟时间（进程运行时间总量，与同时运行的进程数有关）、用户CPU时间（用户指令）、系统CPU时间（内核程序）</li>
<li>系统调用和库函数<br/>
系统调用：程序向内核请求服务，OS所提供的进入内核的<strong>入口点</strong>　　
库函数可替换，系统调用不能替换；malloc<strong>函数</strong>（用户层次）， sbrk<strong>系统调用</strong>（内核层次）<br/>
区别：从用户的角度来看，它们都可以通过C来调用；从实现的角度来看，系统调用是操作系统内核提供的服务，库函数则一般基于系统调用实现；系统调用提供<strong>最小接口</strong>，库函数提供比较复杂的功能<br/>
<img src="/images/apue/1.11.png" title="diff between library function and system call" alt="img" /></li>
</ol>


<p><br></p>

<h1>chapter 2: UNIX标准化及实现</h1>

<ol>
<li>引言</li>
<li>UNIX标准化

<ol>
<li>ISO C<br/>
1989年，C程序设计语言的ANSI（American National Standards Institute）标准X3.159-1989得到批准(ANSI 1989)。此标准已被采用为国际标准ISO/IEC 9899:1990。1999年，ISO C被更新为ISO/IEC 9899:1999，改善了对数值处理的支持。<br/>
ISO C标准的意图是提供C程序在不同OS的可移植性。<br/>
按照ISO C标准定义的各个头文件（header），可将ISO C库分成24个区。下表列出了C标准定义的各个头文件。<br/>
<img src="/images/apue/2.2.1.png" title="iso c" alt="img" /></li>
<li>IEEE POSIX <br/>
POSIX是一系列由IEEE（Institute of Electrical and Electronics Engineers）制定的标准，POSIX（Portable Operating System Interface）是指可移植的操作系统接口。<br/>
本书使用POSIX.1，下面4个表总结了POSIX.1指定的必需和可选的头文件。因为POSIX.1包含ISO C标准库函数，所以还需要ISO C中列出的头文件。<br/>
下表为POSIX标准定义的必需的头文件<br/>
<img src="/images/apue/2.2.2.1.png" alt="img" /><br/>
下表为POSIX标准定义的XSI扩展头文件<br/>
<img src="/images/apue/2.2.2.2.png" alt="img" /><br/>
下表为POSIX标准定义的可选头文件<br/>
<img src="/images/apue/2.2.2.3.png" alt="img" /><br/>
POSIX接口可以分为必需接口和可选接口，可选接口按功能又进一步分成50个区，下表总结了没有被弃用的编程接口<br/>
<img src="/images/apue/2.2.2.4.png" alt="img" /></li>
<li>Single UNIX Specification<br/>
Single UNIX Specification（单一UNIX规范）是POSIX.1标准的一个超集，它定义了一些附加的接口，这些接口扩展了POSIX.1规范所提供的功能。相应的系统接口全集被称为X/open系统接口（XSI，X/Open System Interface）。XSI还定义了必须支持POSIX.1中的哪些可选部分才能认为是遵循XSI的（上表中的SUS强制要求），只有遵循XSI的实现才能成为UNIX系统。</li>
<li>FIPS<br/>
FIPS的含义是联邦信息处理标准（Federal Information Processing Standard），它是由美国政府出版，用于计算机系统的采购</li>
</ol>
</li>
<li>UNIX系统实现<br/>
UNIX主要有三个分支：<br/>
AT&amp;T分支，导出了系统Ⅲ和系统Ⅴ（被称为UNIX的商用版本）<br/>
加州大学伯克利分校分支，导出了4.xBSD实现。<br/>
AT&amp;T贝尔实验室的UNIX研究版

<ol>
<li>SVR4（UNIX System V Release 4）, AT&amp;T的UNIX系统实验室产品</li>
<li>4.4BSD（Berkeley Software Distribution）加州大学伯克利分校的计算机系统研究组研究开发和分发</li>
<li>FreeBSD<br/>
加州大学伯克利分校的计算机系统研究组决定终止其在UNIX操作系统的BSD版本上的研发中作后，设立了FreeBSD项目。</li>
<li>Linux
其实不是UNIX，Linus Torvalds在1991年为替代MINIX而研发的</li>
<li>Mac OS X，核心操作系统为Darwin，基于Mach内核和FreeBSD OS的组合</li>
<li>Solaris，Sun公司开发的UNIX版本</li>
<li>其他UNIX系统

<ul>
<li>AIX， IBM版的UNIX系统</li>
<li>HP-UX， HP版</li>
<li>IRIX， Silicon Graphics版的UNIX</li>
<li>Unix Ware, SVR4衍生的UNIX系统</li>
</ul>
</li>
</ol>
</li>
<li>标准和实现的关系</li>
<li>限制<br/>
 UNIX使用以下两种类型的限制：<br/>
 编译时限制（例如：短整型最大值是多少？）<br/>
 运行时限制（例如：文件名可以有多少个字符？）<br/>
 对于上面的2种限制具体是怎么实现的呢：<br/>
 编译时限制（使用头文件）<br/>
 不与文件或目录相关联的运行时限制（使用sysconf函数）<br/>
 与文件或目录相关联的运行时限制（使用pathconf函数和fpathconf函数）

<ol>
<li>ISO C限制</li>
<li>POSIX限制</li>
<li>XSI限制</li>
<li>sysconf、pathconf和fpathconf函数</li>
<li>不确定的运行时限制

<ol>
<li>路径名</li>
<li>最大打开文件数</li>
</ol>
</li>
</ol>
</li>
<li>选项</li>
<li>功能测试宏</li>
<li>基本系统数据类型，头文件<code>&lt;sys/type.h&gt;</code>定义，大多数以<code>_t</code>结尾，如<code>dev_t</code>,<code>pid_t</code>,<code>size_t</code>,<code>time_t</code>等待，具体含义如下表所示<br/>
 <img src="/images/apue/2.8.png" title="primitive system data type" alt="img" /></li>
<li>标准之间的冲突</li>
<li>小结；本章对ISO C, POSIX和Single UNIX Specification三个标准进行说明，以及这些标准对各种UNIX OS的印象。标准化工作的重要部分是说明“各种实现定义的各种<strong>限制</strong>”</li>
</ol>


<p><br></p>

<h1>chapter 3: 文件I/O</h1>

<ol>
<li>引言<br/>
 5个文件I/O函数：<code>open</code>，<code>read</code>，<code>write</code>，<code>lseek</code>，<code>close</code>，不同缓冲区长度对read和write的影响<br/>
 本章所说明的函数被称为<strong>不带缓冲的I/O</strong>（unbuffered I/O），<strong>不带缓冲</strong>指的是每个read和write都调用内核的一个系统调用。不带缓冲的I/O函数不是ISO C的组成成分，是POSIX.1和Single UNIX Specification的组成部分<br/>
 原子操作，通过文件I/O和open函数的参数来讨论；多进程共享文件，涉及的内核数据结构；<code>dup</code>，<code>fcntl</code>，<code>sync</code>，<code>fsync</code>和<code>ioctl</code>函数</li>
<li>文件描述符<br/>
 使用open或creat时，内核向进程返回fd，作为参数传给read或write
 0、1、2分别与stdin、stdout、stderr关联</li>
<li>open函数<br/>
 <code>
 #include &lt;fcntl.h&gt;
 int open(const char *pathname, int oflag, ...);
</code> <br/>
 oflag可为O_RDONLY,O_WRONLY,O_RDWR，还有其他可选参数，这些常量在<code>&lt;fcntl.h&gt;</code>定义<br/>
 返回最小的未用描述符数值</li>
<li>creat函数<br/>
 <code>
 #include &lt;fcntl.h&gt;
 int creat(const char *pathname, mode_t mode);
</code><br/>
 等效于<code>open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)</code><br/>
 creat缺点：只能以<em>只写方式</em>打开创建的文件，如果要先写后读，只能调用creat,再close,再调用open。现在可以这样<code>open(pathname, O_RDWR | O_CREAT |O_TRUNC, mode)</code></li>
<li>close函数<br/>
 <code>
 #include &lt;unistd.h&gt;
 int close(int fd);
</code> <br/>
 关闭文件还会释放<em>加在文件上的所有记录锁</em><br/>
 进程终止，内核自动关闭该进程打开的文件</li>
<li>lseek函数<br/>
 <strong>当前文件偏移量</strong><br/>
 <code>
 #include &lt;unistd.h&gt;
 off_t lseek(int fd, off_t offset, int whence);
 /* 返回值： 成功则返回新的文件偏移量，否则返回-1 */
</code> <br/>
 whence可为:

<ul>
<li><code>SEEK_SET</code>(0, 最终偏移量=文件开始+offset)</li>
<li><code>SEEK_CUR</code>(1, 最终偏移量=当前位置+offset)</li>
<li><code>SEEK_END</code>(2, 最终偏移量=文件末尾+offset)</li>
</ul>
</li>
</ol>


</div>

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>15 Sep 2014</span> &raquo; <a href="/2014/09/15/notes-of-the-c-programming-language.html">Notes of the C Programming Language</a></li>
    
      <li><span>14 Sep 2014</span> &raquo; <a href="/2014/09/14/markdown-learning.html">Markdown学习笔记</a></li>
    
      <li><span>11 Sep 2014</span> &raquo; <a href="/2014/09/11/alg-homework.html">算法设计的作业</a></li>
    
  </ul>

</div>

<!--
<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'everendless';
  
  (function() {	
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
-->

<!-- 多说评论框 start -->
<div class="ds-thread" data-thread-key=/2014/09/22/notes-of-apue data-title=Notes of APUE data-url=elviskwok.github.io/2014/09/22/notes-of-apue.html></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"elviskwok"};
  (function() {
  var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
<!-- 多说公共JS代码 end -->

  
  <div class="footer">
    <div class="contact">
      <p>
        Elvis Kwok<br />
        Graduate student of <a href="http://sysu.edu.cn/">Sun-Yatsen University</a><br />
        <a href="mailto:359619839@qq.com">359619839@qq.com</a>
      </p>
    </div>
    <div class="contact">
      <p>
        <a href="http://github.com/ElvisKwok/">github.com/ElvisKwok</a><br />
        <a href="http://weibo.com/everendless/">weibo.com/everendless</a><br />
        <a href="http://"></a>
      </p>
    </div>
	
	<!--
    <div class="rss">
      <a href="http://feeds.feedburner.com/">
        <img src="/images/rss.png" alt="Subscribe to RSS Feed" />
      </a>
    </div>
	-->

  </div>
</div>

<!-- top right corner -->
<!--
<a href="http://github.com/ElvisKwok"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
-->

<!-- ClickTale Bottom part -->
<div id="ClickTaleDiv" style="display: none;"></div>
<script type="text/javascript">
if(document.location.protocol!='https:')
  document.write(unescape("%3Cscript%20src='http://s.clicktale.net/WRb.js'%20type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
if(typeof ClickTale=='function') ClickTale(206,0.3,"www03");
</script>
<!-- ClickTale end of Bottom part -->

<!-- Google Analytics -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-6016902-1");
pageTracker._trackPageview();
</script>
<!-- Google Analytics end -->



															


</body>
</html>
